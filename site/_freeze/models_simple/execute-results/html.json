{
  "hash": "b6e0b00992364be1a25d8c44b0b19333",
  "result": {
    "engine": "jupyter",
    "markdown": "# A simple Rt estimator  {#sec-models-simple}\n\n::: {#494dffd5 .cell execution_count=1}\n``` {.julia .cell-code code-fold=\"true\"}\nusing Distributions\ninclude(\"../src/loadData.jl\")\n```\n:::\n\n\nThe reproduction number $R_t$ is a key component in the renewal model, however it is also always unknown. We thus dedicate an entire section to estimating this quantity.\n\nWe start by reproducing the simple example first outlined in @sec-smc-bootstrapexample, using some pre-built functions. A full exposé of these functions is provided in @sec-structure, but the outline here may be sufficient.\n\nRecall that we model $\\log R_t$ with a Gaussian random walk:\n\n$$\\log R_t \\sim \\text{Normal}(\\log R_{t-1}, \\sigma) $$\n\nand assume reported cases follow the Poisson renewal model:\n\n$$ C_t | R_t, C_{1:t}, \\theta \\sim \\text{Poisson}\\left(R_t \\sum_{u=1}^{t-1} C_{t-u} g_u\\right) $$\n\n\n## Defining the model\n\nFirst we define the parameters:\n\n::: {#57955009 .cell execution_count=2}\n``` {.julia .cell-code}\nσ = 0.2\n```\n:::\n\n\nthe data:\n\n::: {#78424809 .cell execution_count=3}\n``` {.julia .cell-code}\nY = loadData(\"NZCOVID\")\n```\n:::\n\n\nand the options dictionary:\n\n::: {#ada5f6b0 .cell execution_count=4}\n``` {.julia .cell-code}\nopts = Dict()\nopts[\"N\"] = 1000 # Number of particles (can use fewer as we are starting with parameter inference)\nopts[\"T\"] = length(Y.Ct) # Length of data\nopts[\"L\"] = 50 # Resampling window\nopts[\"pR0\"] = Uniform(0,10) # Initial distribution for Rt\nω = pdf.(Gamma(2.36, 2.74), 1:100) # (Unnormalised) serial interval\nopts[\"ω\"] = ω/sum(ω) # Serial interval\n```\n:::\n\n\nNow, all we need to do is write the model as a bootstrap filter:\n\n::: {#5a752904 .cell execution_count=5}\n``` {.julia .cell-code}\nfunction simpleModel(σ, Y::DataFrame, opts::Dict)\n\n    # Extract frequently used options\n    T = opts[\"T\"]\n    N = opts[\"N\"]\n    L = opts[\"L\"]\n\n    # Initialise output matrices\n    R = zeros(N, T) # Using R instead of X to highlight we're estimating Rt\n    W = zeros(N, T)\n\n    # Sample from initial distribution\n    R[:,1] = rand.(opts[\"pR0\"], N)\n\n    # Run the filter\n    for tt = 2:T\n\n        # Project according to the state-space model\n        R[:,tt] = exp.(rand.(Normal.(log.(R[:,tt-1]), σ)))\n\n        # Weight according to the observation model\n        Λ = sum(Y.Ct[tt-1:-1:1] .* ω[1:tt-1])\n        W[:,tt] = pdf.(Poisson.(R[:,tt] .* Λ), Y.Ct[tt])\n\n        # Resample\n        inds = wsample(1:N, W[:,tt], N; replace=true)\n        R[:, max(tt - L, 1):tt] = R[inds, max(tt - L, 1):tt]\n\n    end\n\n    return(R, W)\n\nend\n```\n:::\n\n\n## Estimating $\\sigma$\n\nWe use the simple PMMH algorithm to estimate $\\sigma$. We need to specify some additional options for this:\n\n::: {#d35e1b97 .cell execution_count=6}\n``` {.julia .cell-code}\nopts[\"nChains\"] = 3\nopts[\"nPMMHSamples\"] = 1000\n\nopts[\"paramPriors\"] = [Uniform(0, 1.0)] # A vector of prior distributions for the parameter(s)\nopts[\"proposalDists\"] = [(x) -> Truncated(Normal(x, 0.03), 0, 1.0)] # A vector of proposal distributions for the parameter(s)\nopts[\"initialParamSamplers\"] = [Uniform(0.05, 0.3)] # A vector of distributions to sample initial parameter values from\n```\n:::\n\n\nWe also want to check that we are using a sufficient number of particles to obtain good estimates of $\\ell(\\theta|y_{1:T})$:\n\n::: {#fa82d8b7 .cell execution_count=7}\n``` {.julia .cell-code}\ninclude(\"../src/Likelihood.jl\")\n(sd, logliks) = estimateStdDevLogLik(100, simpleModel, σ, Y, opts)\nprintln(\"Standard deviation of log-lik estimates = $sd\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\rEstimating log-likelihood multiple times... 100%|██████████████████████████████████████████████████| Time: 0:00:02\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nStandard deviation of log-lik estimates = 0.5611409956765454\n```\n:::\n:::\n\n\nNow we are ready to run the PMMH algorithm:\n\n::: {#02c14082 .cell execution_count=8}\n``` {.julia .cell-code}\ninclude(\"../src/PMMHSimple.jl\")\n(θ, diagnostics) = multipleSimplePMMH(simpleModel, Y, opts; showProgress=false)\n```\n:::\n\n\nand analyse it using the MCMCChains package:\n\n::: {#348885b2 .cell execution_count=9}\n``` {.julia .cell-code}\nusing MCMCChains\nC = Chains(θ[100:end,:,:], [\"σ\"]) # Removing the first 100 samples as a windin\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>Chains MCMC chain (901×1×3 Array{Float64, 3}):\nIterations        = 1:1:901\nNumber of chains  = 3\nSamples per chain = 901\nparameters        = σ\nSummary Statistics\n <span class=\"ansi-bold\"> parameters </span> <span class=\"ansi-bold\">    mean </span> <span class=\"ansi-bold\">     std </span> <span class=\"ansi-bold\"> naive_se </span> <span class=\"ansi-bold\">    mcse </span> <span class=\"ansi-bold\">      ess </span> <span class=\"ansi-bold\">    rhat </span>\n <span class=\"ansi-bright-black-fg\">     Symbol </span> <span class=\"ansi-bright-black-fg\"> Float64 </span> <span class=\"ansi-bright-black-fg\"> Float64 </span> <span class=\"ansi-bright-black-fg\">  Float64 </span> <span class=\"ansi-bright-black-fg\"> Float64 </span> <span class=\"ansi-bright-black-fg\">  Float64 </span> <span class=\"ansi-bright-black-fg\"> Float64 </span>\n           σ    0.2382    0.0436     0.0008    0.0029   189.2514    1.0080\nQuantiles\n <span class=\"ansi-bold\"> parameters </span> <span class=\"ansi-bold\">    2.5% </span> <span class=\"ansi-bold\">   25.0% </span> <span class=\"ansi-bold\">   50.0% </span> <span class=\"ansi-bold\">   75.0% </span> <span class=\"ansi-bold\">   97.5% </span>\n <span class=\"ansi-bright-black-fg\">     Symbol </span> <span class=\"ansi-bright-black-fg\"> Float64 </span> <span class=\"ansi-bright-black-fg\"> Float64 </span> <span class=\"ansi-bright-black-fg\"> Float64 </span> <span class=\"ansi-bright-black-fg\"> Float64 </span> <span class=\"ansi-bright-black-fg\"> Float64 </span>\n           σ    0.1642    0.2063    0.2364    0.2679    0.3248\n</pre>\n```\n:::\n\n:::\n:::\n\n\nso the posterior mean of $\\theta$ is approximately 0.17 with a 95\\% credible interval of $(0.10, 0.20)$. The $\\hat{R}$ statistic is less than 1.05, suggesting the chains have converged, although additional samples may be desirable for full confidence. To double check, we can also plot the chains and posterior density estimate:\n\n::: {#694c577e .cell execution_count=10}\n``` {.julia .cell-code}\nusing StatsPlots, Measures\nplot(C, size=(800,300), margins=3mm)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n![](models_simple_files/figure-html/cell-11-output-1.svg){}\n:::\n:::\n\n\n### Marginalising out $\\sigma$\n\n#TODO: Write full posterior code\n\n",
    "supporting": [
      "models_simple_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}