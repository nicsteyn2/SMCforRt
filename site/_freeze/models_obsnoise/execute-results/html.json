{
  "hash": "031ddae1c4843a85d9aa11cb0b008e37",
  "result": {
    "engine": "jupyter",
    "markdown": "# Modelling observation noise {#sec-models-obsnoise}\n\n::: {#631c56c5 .cell execution_count=1}\n``` {.julia .cell-code code-fold=\"true\"}\nusing Plots, Measures\ninclude(\"../src/loadData.jl\")\ninclude(\"../src/FitModel.jl\")\n\nY = loadData(\"NZCOVID\")\n```\n:::\n\n\nObservation noise is frequently highlighted as...\n\n\nAll five models introduced below leverage the same state-space model:\n\n$$\n\\begin{align}\n\\log R_t | \\log R_{t-1} &\\sim \\text{Normal}(\\log R_{t-1}, \\sigma) \\\\\nI_t | R_t, I_{1:t-1} &\\sim \\text{Poisson}(R_t \\Lambda_t)\n\\end{align}\n$$ {#eq-models-obsnoise-statespace}\n\nand differ only in the observation model.\n\n\n\n## Underreporting {#sec-models-obsnoise-underreport}\n\nIf we assume that each case has an independent probability of being reported, we can model $C_t$ using a Binomial distributon:\n$$\nC_t | I_t \\sim \\text{Binomial}\\left(I_t, \\ \\rho\\right)\n$$ {#eq-models-obsnoise-obsdist}\n\nThe reporting rate $\\rho$ is not identifiable from reported case data alone^[#TODO: See if we can still estiamte it purely from a allow-for-variance standpoint], so must be set by the user. We use $\\rho = 0.5$ below as an example. This model thus has the same number of parameters as the basic model (one parameter, $\\sigma$). The hidden-state model can be written as:\n\n::: {#d28cf399 .cell execution_count=2}\n``` {.julia .cell-code code-fold=\"true\"}\nfunction underreportingModel(σ, Y::DataFrame, opts::Dict)\n\n    # Specify reporting rate\n    ρ = 0.5\n\n    # Extract frequently used options\n    T = opts[\"T\"]\n    N = opts[\"N\"]\n    L = opts[\"L\"]\n\n    # Initialise output matrices\n    R = zeros(N, T)\n    I = zeros(N, T)\n    W = zeros(N, T)\n\n    # Sample from initial distributions\n    R[:,1] = rand.(opts[\"pR0\"], N)\n    I[:,1] = rand.(opts[\"pI0\"], N)\n\n    # Run the filter\n    for tt = 2:T\n\n        # Project according to the state-space model\n        R[:,tt] = exp.(rand.(Normal.(log.(R[:,tt-1]), σ)))\n        Λ = sum(I[:, (tt-1):-1:1] .* ω[1:(tt-1)]', dims=2)\n        I[:,tt] = rand.(Poisson.(R[:,tt] .* Λ))\n\n        # Weight according to the observation model\n        W[:,tt] = pdf.(Binomial.(I[:,tt], ρ), Y.Ct[tt])\n\n        # Resample\n        inds = wsample(1:N, W[:,tt], N; replace=true)\n        R[:, max(tt - L, 1):tt] = R[inds, max(tt - L, 1):tt]\n        I[:, max(tt - L, 1):tt] = I[inds, max(tt - L, 1):tt]\n\n    end\n\n    # Store output as three-dimensional array\n    X = zeros(N, T, 2)\n    X[:,:,1] = R\n    X[:,:,2] = I\n\n    return(X, W)\n\nend\n```\n:::\n\n\nand we also set model options:\n\n::: {#1723bb4b .cell execution_count=3}\n``` {.julia .cell-code code-fold=\"true\"}\n# Bootstrap filter options\nopts = Dict()\nopts[\"T\"] = 100\nopts[\"N\"] = 1000\nopts[\"L\"] = 50\nopts[\"pR0\"] = Uniform(0, 10)\nopts[\"pI0\"] = DiscreteUniform(1, 5)\nω = pdf.(Gamma(2.36, 2.74), 1:100)\nopts[\"ω\"] = ω / sum(ω)\n\n# PMMH options\nopts[\"nChains\"] = 3\nopts[\"chunkSize\"] = 100\nopts[\"maxChunks\"] = 10\nopts[\"maxRhat\"] = 1.05\nopts[\"minESS\"] = 100\nopts[\"showEpochProgress\"] = false\nopts[\"paramPriors\"] = [Uniform(0, 1)]\nopts[\"initialParamSamplers\"] = [Uniform(0.1, 0.3)]\nopts[\"propStdDevInit\"] = [0.1]\nopts[\"paramLimits\"] = [(0, 1)]\n\n# Posterior options\nopts[\"posteriorNumberOfParticles\"] = 10000\nopts[\"posteriorParamSamples\"] = 10\nopts[\"stateNames\"]  = [\"Rt\", \"It\"]\nopts[\"paramNames\"] = [\"sigma\"]\n```\n:::\n\n\nThen we can use ```fitModel()``` to run the PMMH algorithm and return the marginalised estimates of $R_t$:\n\n::: {#767af8cf .cell execution_count=4}\n``` {.julia .cell-code}\n(df_states, df_params, diag) = fitModel(underreportingModel, Y, opts)\n```\n:::\n\n\n::: {#4b11e737 .cell execution_count=5}\n``` {.julia .cell-code code-fold=\"true\"}\ndf_R = df_states[df_states.variable .== \"Rt\",:]\ndf_I = df_states[df_states.variable .== \"It\",:]\n\nplotR = plot(df_R.date, df_R.mean, ribbon=(df_R.mean-df_R.lower, df_R.upper-df_R.mean), label=false, color=:darkgreen, xlabel=\"Date\", ylabel=\"Reproduction number\")\nplotI = scatter(df_I.date, df_I.mean, yerror=(df_I.mean-df_I.lower, df_I.upper-df_I.mean), label=false, color=:darkgreen, xlabel=\"Date\", ylabel=\"Infection incidence\", markersize=2)\nplot(plotR, plotI, layout=(2,1), size=(800,400), margins=3mm)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n![](models_obsnoise_files/figure-html/cell-6-output-1.svg){}\n:::\n:::\n\n\n<!-- ## Underreporting and overdispersion {#sec-models-obsnoise-underreportandover}\n\nCase reporting can often be over-dispersed, exhibiting greater variance than implied by the binomial observation distribution above. Instead, we can use a beta-binomial distribution:\n\n$$\nC_t | I_t \\sim \\text{Beta-binomial}\\left(I_t, \\alpha_t, \\beta_t\\right)\n$$ {#eq-models-obsnoise-obsdistover}\n\nwhere:\n\n$$\n\\alpha_t = \\rho n^*, \\ \\ \\beta_t = (1-\\rho) n^*\n$$ {#eq-models-obsnoise-obsdistoverparams}\n\nThis model also assumes a reporting rate of $\\rho$, but allows for additional variance through parameter $n^*$^[The beta-binomial explicitly assumes that $I_t$ are binomially distributed with random probability $\\rho \\sim Beta(\\alpha_t, \\beta_t)$. Under this interpretation, $n^*$ can be thought of as the number of \"prior trials\", and $\\alpha_t$ the number of \"prior successes\".]. We now must estimate two parameters: $\\sigma$ and $n^*$. -->\n\n\n## Observation noise\n\nIn @sec-models-obsnoise-underreport, we assumed a pre-determined reporting rate $\\rho$, naturally introducing some reporting noise. Without additional information this parameter is not (typically) identifiable. If we do not want to assume a value of $\\rho$, a popular distribution for modelling (potentially) overdispersed data is the negative binomial:\n\n$$\nC_t | I_t \\sim \\text{Negative binomial}\\left(r = \\frac{I_t}{k}, p=\\frac{1}{1 + k} \\right)\n$$\n\nwhich has mean $I_t$ and variance $(1+k) I_t$, where $k$ is a dispersion parameter. This results in two parameters to be estimated: $\\sigma$ and $k$.\n\n::: {#3a05fe7d .cell execution_count=6}\n``` {.julia .cell-code code-fold=\"true\"}\nfunction overdispersedModel(θ, Y::DataFrame, opts::Dict)\n\n    # Extract frequently used options\n    T = opts[\"T\"]\n    N = opts[\"N\"]\n    L = opts[\"L\"]\n\n    # Initialise output matrices\n    R = zeros(N, T)\n    I = zeros(N, T)\n    W = zeros(N, T)\n\n    # Sample from initial distributions\n    R[:,1] = rand.(opts[\"pR0\"], N)\n    I[:,1] = rand.(opts[\"pI0\"], N)\n\n    # Run the filter\n    for tt = 2:T\n\n        # Project according to the state-space model\n        R[:,tt] = exp.(rand.(Normal.(log.(R[:,tt-1]), θ[1])))\n        Λ = sum(I[:, (tt-1):-1:1] .* ω[1:(tt-1)]', dims=2)\n        I[:,tt] = rand.(Poisson.(R[:,tt] .* Λ))\n\n        # Weight according to the observation model\n        r = I[:,tt] / θ[2]\n        p = 1 / (1 + θ[2])\n        W[:,tt] = fastNegativeBinomialPDF(Y.Ct[tt], r, p)\n\n        # Resample\n        inds = wsample(1:N, W[:,tt], N; replace=true)\n        R[:, max(tt - L, 1):tt] = R[inds, max(tt - L, 1):tt]\n        I[:, max(tt - L, 1):tt] = I[inds, max(tt - L, 1):tt]\n\n    end\n\n    # Store output as three-dimensional array\n    X = zeros(N, T, 2)\n    X[:,:,1] = R\n    X[:,:,2] = I\n\n    return(X, W)\n\nend\n\n\n# Particle filter options\nopts = Dict()\nopts[\"T\"] = 100\nopts[\"N\"] = 1000\nopts[\"L\"] = 50\nopts[\"pR0\"] = Uniform(0, 10)\nopts[\"pI0\"] = DiscreteUniform(1, 5)\nω = pdf.(Gamma(2.36, 2.74), 1:100)\nopts[\"ω\"] = ω / sum(ω)\n\n# # Simple PMMH options\n# opts[\"nPMMHSamples\"] = 500\n# opts[\"paramPriors\"] = [Uniform(0, 1)]\n# opts[\"initialParamSamplers\"] = [Uniform(0.1, 0.3)]\n# opts[\"proposalDists\"] = [(x) -> Truncated(Normal(x, 0.12), 0, 1)]\n# opts[\"nChains\"] = 3\n\n# PMMH options\nopts[\"nChains\"] = 3\nopts[\"chunkSize\"] = 100\nopts[\"maxChunks\"] = 10\nopts[\"maxRhat\"] = 1.1\nopts[\"minESS\"] = 100\nopts[\"showEpochProgress\"] = false\nopts[\"paramPriors\"] = [Uniform(0, 1), Uniform(0, 10)]\nopts[\"initialParamSamplers\"] = [Uniform(0.1, 0.3), Uniform(0.1, 0.5)]\nopts[\"propStdDevInit\"] = [0.05, 0.1]\nopts[\"paramLimits\"] = [(0, 1), (0, 10)]\n\n# Posterior options\nopts[\"posteriorNumberOfParticles\"] = 10000\nopts[\"posteriorParamSamples\"] = 10\nopts[\"stateNames\"]  = [\"Rt\", \"It\"]\nopts[\"paramNames\"] = [\"sigma\", \"k\"]\n```\n:::\n\n\n### Observation noise and underreporting\n\n\n\n## Day-of-the-week effects\n\n\n## Reporting delays\n\n\n## Concluding remarks\n\nModels involving reporting delays or day-of-the-week effects without stochasticity (that is, where $C_t = f(I_{1:t})$ for some deterministic function $f$) will be highly inefficient. The observation distribution in such as a case takes values $1$ (where $C_t = f(I_{1:t})$) or $0$ (where $C_t \\neq f(I_{1:t})$).\n\n",
    "supporting": [
      "models_obsnoise_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}