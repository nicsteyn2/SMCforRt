{
  "hash": "65c262dabb3c8962433df00a1bfe8906",
  "result": {
    "engine": "jupyter",
    "markdown": "# The renewal model {#sec-intro}\n\nThe renewal model is a simple model of infectious disease transmission. It relates past cases to current cases through a serial interval and reproduction number. It is typically written:\n\n$$\nE[C_t] = R_t \\sum_{u=1}^{u_{max}} C_{t-u} \\omega_u\n$$ {#eq-intro-renewal}\n\nwhere:\n\n- $C_t$: the number of **cases reported** on time-step $t$\n- $R_t$: the **instantaneous reproduction number** at time-step $t$. Defined as the average number of secondary cases produced by an infected individual, if they were to have their entire infectious period at the current time-step.\n- $\\omega_u$: the **serial interval**. The probability that a secondary case was reported $u$ days after the primary case. $u_{max}$ denotes the maximum value of $u$ for which $\\omega_u > 0$.\n\n![Diagram of the renewal model. In this example, the serial interval takes values ωu = 0.25, 0.5, 0.25 for u = 1, 2, 3 (a maximum serial interval of three days) and the reproduction number is assumed to take values Rt–1 = 2, Rt = 2, and Rt+1 = 1. On the left, the expected number of secondary cases produced by a primary case who was reported at time t–2 is shown (0.5 cases on day t–1, a single case on day t, and 0.25 cases on day t+1), with their expected contribution to total cases at time t highlighted. On the right, the expected total cases at time t is shown as the sum of the expected cases produced by primary cases reported u = 1, 2, and 3 days ago, defining the renewal equation.](images/intro-renewalmodel-diagram.png){#fig-intro-diagram}\n\nWe also need to specify a distribution for $C_t$. The canonical choice is the *Poisson renewal model*:\n\n$$\nC_t|R_t, C_{1:t-1} \\sim \\text{Poisson}\\left(R_t \\sum_{u=1}^{u_{max}} C_{t-u} \\omega_u \\right)\n$$ {#eq-intro-poissonrenewal}\n\nFinally, we often denote the summation in the renewal model using:\n\n$$\n\\Lambda_t^c = \\sum_{u=1}^{u_{max}} C_{t-u} \\omega_u\n$$ {#eq-intro-forceofinfection}\n\nwhere $\\Lambda_t^c$ is called the **force-of-infection** at time $t$. The superscript $c$ denotes that $\\Lambda_t^c$ is calculated using past reported cases, to differentiate it from $\\Lambda_t$, which we use when modelling *infections* (see @sec-intro-casesvsinfections).\n\n## Simulating the renewal model\n\nTo understand how the renewal model works, let's start by simulating $T = 100$ days of reported cases from it. To do this, we need **three components**:\n\n1. **Initial cases** $C_1$. Let's start with $C_1 = 50$.\n\n::: {#70a562f7 .cell execution_count=1}\n``` {.julia .cell-code}\nT = 100\nC = zeros(T)\nC[1] = 50 # Specify C_1 = 50\n```\n:::\n\n\n2. The **reproduction number** over time. We will use a sin-curve alternating between $R_t = 1.5$ and $R_t = 0.5$ with a period of 50 days for this example:\n\n::: {#50dd581a .cell execution_count=2}\n``` {.julia .cell-code}\nR = 1.0 .+ 0.5 * sin.((2*π/50) .* (1:T))\n```\n:::\n\n\n3. A **serial interval**. We use a discretised Gamma(2.36, 2.74)^[This is a popular serial interval used in early COVID-19 models [@paragDecipheringEarlywarningSignals2021; @fergusonReportImpactNonpharmaceutical2020].] distribution:\n\n::: {#f2f76696 .cell execution_count=3}\n``` {.julia .cell-code}\nusing Distributions\n\nω = pdf.(Gamma(2.36, 2.74), 1:T)\nω = ω/sum(ω) # Ensure it is normalised!\n```\n:::\n\n\nPlotting our chosen $R_t$ and serial interval:\n\n::: {#cell-fig-intro-simulatedRtSerial .cell execution_count=4}\n``` {.julia .cell-code code-fold=\"true\"}\n# Visualise Rt and the serial interval\nusing Plots, Measures\nplotR = plot(R, label=false, xlabel=\"Time (days)\", ylabel=\"Reproduction number\", color=:darkgreen, linewidth=3)\nplotω = bar(1:21, ω[1:21], label=false, xlabel=\"Day\", ylabel=\"Serial interval probability\", color=:darkorange)\ndisplay(plot(plotR, plotω, layout=(1,2), size=(800,300), margins=3mm))\n```\n\n::: {.cell-output .cell-output-display}\n![Assumed time-varying reproduction number and serial intervals.](introduction_files/figure-html/fig-intro-simulatedrtserial-output-1.svg){#fig-intro-simulatedrtserial}\n:::\n:::\n\n\nNow we are ready to simulate from the renewal model. We do this by iteratively sampling a new $C_t$ and calculating the new force-of-infection term:\n\n::: {#309d66f2 .cell execution_count=5}\n``` {.julia .cell-code}\nfor tt = 2:T\n\n    # Calculate the force-of-infection\n    Λ = sum(C[tt-1:-1:1] .* ω[1:tt-1])/sum(ω[1:tt-1])\n\n    # And sample from the appropriate Poisson distribution\n    C[tt] = rand(Poisson(R[tt] * Λ))\n\nend\n```\n:::\n\n\nFinally letting us plot our simulated cases:\n\n::: {#cell-fig-intro-simulatedcases .cell execution_count=6}\n``` {.julia .cell-code code-fold=\"true\"}\ndisplay(bar(C, label=false, xlabel=\"Time (days)\", ylabel=\"Simulated cases\", size=(800,300), margins=3mm, color=:darkblue))\n```\n\n::: {.cell-output .cell-output-display}\n![Simulated epidemic from the renewal model using our chosen values of Rt and ω.](introduction_files/figure-html/fig-intro-simulatedcases-output-1.svg){#fig-intro-simulatedcases}\n:::\n:::\n\n\n::: {.callout-tip title=\"Julia\"}\nThese codeblocks are written in the programming language Julia, which should (mostly) make sense to those familiar with R/Python/MATLAB. One key difference between these languages and Julia is **broadcasting**.\n\nBroadcasting allows functions to be called *elementwise*. For example, when defining `R` above, we write:\n\n```julia\nR = 1.0 .+ 0.5 * sin.(...)\n```\n\nAs `1.0` is a scalar and `0.5 * sin.(...)` is a vector, the `.` before the `+` tells Julia to add 1 to each *element* of `0.5 * sin.(...)`. Similarly, the `.` in `sin.(x)` tells Julia to apply the sine function to each element of `x`. Other languages may handle this automatically in some cases, but by being explicit about element-wise operations, Julia avoids ambiguity.\n\nBroadcasting can also be more memory-efficient in certain situations. It also works automatically with user-defined functions.\n:::\n\n\n## Estimating $R_t$ {#sec-intro-Rtestimation}\n\n$R_t$ is a crucial component in the renewal model thus making the renewal model a natural choice for $R_t$ estimation. In fact, even if your goal is not to estimate $R_t$, it is helpful to consider this briefly.\n\nIf $C_t$ is large and the model accurately reflects reality, we can use @eq-intro-poissonrenewal to estimate $R_t$ directly. In the Bayesian setting, a prior distribution is placed on $R_t$ and standard methods are used to find $P(R_t | C_{1:t})$. However, often $C_t$ is small and the data are subject to noise and bias. Estimates from the naive method are thus highly variable.\n\n\n### Example\n\nLet's pretend we don't know $R_t$ and want to estimate it from the simulated data. Like @coriNewFrameworkSoftware2013, we will use a Gamma prior distribution for $R_t$ with shape $a_0 = 1$ and rate $b_0 = 0.2$. As our likelihood is a Poisson distribution, we have a conjugate prior-likelihood, and thus our posterior distribution for $R_t$ is:\n\n$$\nR_t | C_{1:t} \\sim \\text{Gamma}\\left(a_0 + C_t, b_0 + \\sum_{u=1}^{u_{max}} C_{t-u} \\omega_u \\right)\n$$ {#eq-intro-simpleposterior}\n\n::: {#d50adbe5 .cell execution_count=7}\n``` {.julia .cell-code}\n(MeanRt, LowerRt, UpperRt) = (zeros(T), zeros(T), zeros(T)) # Pre-allocate results vectors\n(a0, b0) = (1, 1/5) # Set prior parameters\n\nfor tt = 2:T\n\n    # Find the posterior distribution on day t\n    a = a0 + C[tt]\n    b = b0 + sum(C[tt-1:-1:1] .* ω[1:tt-1])/sum(ω[1:tt-1])\n    PosteriorDist = Gamma(a, 1/b)\n\n    # Save the results\n    MeanRt[tt] = mean(PosteriorDist)\n    LowerRt[tt] = quantile(PosteriorDist, 0.025)\n    UpperRt[tt] = quantile(PosteriorDist, 0.975)\n\nend\n```\n:::\n\n\nWe will compare our estimates with those from a popular model, EpiEstim, which smooths the data by assuming $R_t$ is fixed over a $\\tau$-day (typically $\\tau = 7$) trailing window:\n\n::: {#dc0b2a7b .cell execution_count=8}\n``` {.julia .cell-code}\ninclude(\"../src/RtEstimators.jl\")\nEpiEstimPosterior = EpiEstim(7, ω, C; a0=a0, b0=b0)\n(EpiEstMean, EpiEstLower, EpiEstUpper) = (mean.(EpiEstimPosterior), quantile.(EpiEstimPosterior, 0.025), quantile.(EpiEstimPosterior, 0.975))\n```\n:::\n\n\nFinally, we are ready to plot our results:\n\n::: {#cell-fig-intro-examplert .cell execution_count=9}\n``` {.julia .cell-code code-fold=\"true\"}\nplot(xlabel=\"Time (days)\", ylabel=\"Reproduction number\", size=(800,350), left_margin=3mm, bottom_margin=3mm)\nplot!(2:T, MeanRt[2:T], ribbon=(MeanRt[2:T]-LowerRt[2:T], UpperRt[2:T]-MeanRt[2:T]), fillalpha=0.4, label=\"Unsmoothed posterior\")\nplot!(2:T, EpiEstMean[2:T], ribbon=(EpiEstMean[2:T]-EpiEstLower[2:T], EpiEstUpper[2:T]-EpiEstMean[2:T]), fillalpha=0.4, label=\"EpiEstim (smoothed) posterior\")\nplot!(1:T, R, label=\"True Rt\", color=:black)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n![Estimates of Rt from the basic (unsmoothed) renewal model (blue) and from a smoothed model (EpiEstim, orange).](introduction_files/figure-html/fig-intro-examplert-output-1.svg){#fig-intro-examplert}\n:::\n:::\n\n\n### The necessity and dangers of smoothing {#sec-intro-smoothing}\n\n@fig-intro-examplert highlights both the necessity and dangers of smoothing. Our independent daily estimates (blue) are highly variable and the credible intervals are wide. By using smoothed estimates (orange), we reduce this variance and produce much more confident results. However, our results strongly depend on these smoothing assumptions. In the example above, we can clearly see that the credible intervals produced by EpiEstim often do not include the true value of $R_t$!\n\nSmoothing works by allowing data from multiple days to inform point-estimates. A variety of approaches have been developed, discussed at length in @sec-smoothingmethods. **In fact, many popular renewal-model based estimators of $R_t$ differ only in their choice of smoothing method!**\n\nEpidemic renewal models are usually smoothed by placing assumptions on the dynamics of $R_t$. Examples include assuming $R_t$ is fixed over trailing windows [@coriNewFrameworkSoftware2013], modelling it with splines [@azmonEstimationReproductionNumber2014] or Gaussian processes [@abbottEstimatingTimevaryingReproduction2020], or assuming it follows a random walk [@paragImprovedEstimationTimevarying2021]. Piecewise-constant models, where $R_t$ is assumed to be fixed over different time-windows, are also examples of smoothing [@creswellBayesianNonparametricMethod2023].\n\nSo far we have only considered process noise in the epidemic, but epidemic data are often subject to observation noise, a secondary reason why smoothing is so important.\n\n\n\n## The serial interval\n\nThe other key component in the renewal model is the serial interval $\\omega$. This parameter is typically not identifiable from reported case data (at least at the same time as $R_t$), so it often receives less attention. When fitting renewal models, researchers usually use estimates of the serial interval from other data.\n\n\n## Reported cases vs infections {#sec-intro-casesvsinfections}\n\nThe simple renewal model in @eq-intro-poissonrenewal assumes that old reported cases directly cause new reported cases. This leaves little room for observation noise. Instead, we can assume that old (but typically unobserved) infections cause new infections, writing:\n\n$$\nI_t|R_t, I_{1:t-1} \\sim \\text{Poisson}\\left(R_t \\Lambda_t\\right)\n$$ {#eq-intro-infectionrenewal}\n\nThe force-of-infection becomes:\n\n$$\n\\Lambda_t = \\sum_{u=1}^{u_{max}} I_{t-u} g_u\n$$ {#eq-intro-forceofinfectioninc}\n\nWhere we have replaced the serial interval $\\omega_u$ with a generation time distribution $g_u$, reflecting that we are modelling the delay between infection events instead of reporting events.\n\nExplicitly modelling infections allows us to define an observation distribution:\n\n$$\nP(C_t | I_{1:t})\n$$ {#eq-intro-obsdist}\n\nwhich explicitly links our hidden (a.k.a latent) infections to our reported cases. A plethora of methods exist that can estimate $I_{1:T}$ given $C_{1:T}$.\n\nSeparating case reporting from transmission allows us to model process noise and observation noise separately. This is one of the key advantages provided by our SMC methods.\n\n",
    "supporting": [
      "introduction_files"
    ],
    "filters": [],
    "includes": {}
  }
}