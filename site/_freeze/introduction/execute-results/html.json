{
  "hash": "e8c7c92e67c58504f18f1267722198e4",
  "result": {
    "engine": "jupyter",
    "markdown": "# The renewal model {#sec-intro}\n\nThe renewal model is a simple model of infectious disease transmission. It relates past cases to current cases through a serial interval and reproduction number. It is typically written:\n\n$$\nE[C_t] = R_t \\sum_{u=1}^{u_{max}} C_{t-u} \\omega_u\n$$ {#eq-intro-renewal}\n\nwhere:\n\n- $C_t$: the number of **cases reported** on time-step $t$\n- $R_t$: the **instantaneous reproduction number** at time-step $t$. Defined as the average number of secondary cases produced by an infected individual, if they were to have their entire infectious period at the current time-step.\n- $\\omega_u$: the **serial interval**. The probability that a secondary case was reported $u$ days after the primary case. $u_{max}$ denotes the maximum value of $u$ for which $\\omega_u > 0$.\n\n![Simple diagram outlining the renewal equation](images/diag-introduction-renewalmodel.png){#fig-intro-diagram width=600}\n\nWe also need to specify a distribution for $C_t$. The canonical choice is the *Poisson renewal model*:\n\n$$\nC_t|R_t, C_{1:t-1} \\sim \\text{Poisson}\\left(R_t \\sum_{u=1}^{u_{max}} C_{t-u} \\omega_u \\right)\n$$ {#eq-intro-poissonrenewal}\n\nFinally, we often denote the summation in the renewal model using:\n\n$$\n\\Lambda_t^c = \\sum_{u=1}^{u_{max}} C_{t-u} \\omega_u\n$$ {#eq-intro-forceofinfection}\n\nwhere $\\Lambda_t^c$ is called the **force-of-infection** at time $t$. The superscript $c$ denotes that $\\Lambda_t^c$ is calculated using past reported cases, to differentiate it from $\\Lambda_t$, which we use when modelling *infections*.\n\n## Simulating the renewal model\n\n::: {#79168470 .cell execution_count=1}\n``` {.julia .cell-code code-fold=\"true\"}\n#TODO: Re-label \"Code\" to \"Setup code\"\n\n# Some setting up code!\nusing Distributions\nT = 100 # Number of days we will later simulate\n```\n:::\n\n\nTo understand how the renewal model works, let's start by simulating $T = 100$ days of reported cases from it. To do this, we need **three components**:\n\n1. **Initial cases** $C_1$. Let's start with $C_1 = 50$.\n\n::: {#58368e88 .cell execution_count=2}\n``` {.julia .cell-code}\nC = zeros(T) \nC[1] = 50 \n```\n:::\n\n\n2. The **reproduction number** over time. We will use a sin-curve for this example:\n\n::: {#51fa9216 .cell execution_count=3}\n``` {.julia .cell-code}\nR = 1.0 .+ 0.5 * sin.((2*π/50) .* (1:T))\n```\n:::\n\n\n3. A **serial interval**. We use a discretised Gamma(2.36, 2.74)^[This is a popular serial interval used in early COVID-19 models [@paragDecipheringEarlywarningSignals2021; @fergusonReportImpactNonpharmaceutical2020].] distribution:\n\n::: {#f9bb1b9b .cell execution_count=4}\n``` {.julia .cell-code}\nω = pdf.(Gamma(2.36, 2.74), 1:T)\nω = ω/sum(ω) # Ensure it is normalised!\n```\n:::\n\n\nPlotting our chosen $R_t$ and serial interval:\n\n::: {#cell-fig-intro-simulatedRtSerial .cell execution_count=5}\n``` {.julia .cell-code code-fold=\"true\"}\n# Visualise Rt and the serial interval\nusing Plots, Measures\nplotR = plot(R, label=false, xlabel=\"Time (days)\", ylabel=\"Reproduction number\", color=:darkgreen)\nplotω = bar(1:21, ω[1:21], label=false, xlabel=\"Day\", ylabel=\"Serial interval probability\", color=:darkorange)\ndisplay(plot(plotR, plotω, layout=(1,2), size=(800,300), margins=3mm))\n```\n\n::: {.cell-output .cell-output-display}\n![Assumed time-varying reproduction number and serial intervals.](introduction_files/figure-html/fig-intro-simulatedrtserial-output-1.svg){#fig-intro-simulatedrtserial}\n:::\n:::\n\n\nNow we are ready to simulate from the renewal model. We do this by iteratively sampling a new $C_t$ and calculating the new force-of-infection term:\n\n::: {#c4cfa9e1 .cell execution_count=6}\n``` {.julia .cell-code}\nfor tt = 2:T\n\n    # Calculate the force-of-infection\n    Λ = sum(C[tt-1:-1:1] .* ω[1:tt-1])/sum(ω[1:tt-1])\n\n    # And sample from the appropriate Poisson distribution\n    C[tt] = rand(Poisson(R[tt] * Λ))\n\nend\n```\n:::\n\n\nFinally letting us plot our simulated cases:\n\n::: {#cell-fig-intro-simulatedcases .cell execution_count=7}\n``` {.julia .cell-code code-fold=\"true\"}\ndisplay(bar(C, label=false, xlabel=\"Time (days)\", ylabel=\"Simulated cases\", size=(800,300), margins=3mm, color=:darkblue))\n```\n\n::: {.cell-output .cell-output-display}\n![Simulated epidemic from the renewal model using our chosen values of Rt and ω.](introduction_files/figure-html/fig-intro-simulatedcases-output-1.svg){#fig-intro-simulatedcases}\n:::\n:::\n\n\n## Estimating $R_t$ {#sec-intro-Rtestimation}\n\n$R_t$ is a crucial component in the renewal model thus making the renewal model a natural choice for $R_t$ estimation. In fact, even if your goal is not to estimate $R_t$, it is helpful to consider this briefly.\n\nIf $C_t$ is large and the model accurately reflects reality, we can use @eq-intro-poissonrenewal to estimate $R_t$ directly. In the Bayesian setting, a prior distribution is placed on $R_t$ and standard methods are used to find $P(R_t | C_{1:t})$. However, often $C_t$ is small and the data are subject to noise and bias. Estimates from the naive method are thus highly variable.\n\n\n### Example\n\nLet's pretend we don't know $R_t$ and want to estimate it from the simulated data. Like @coriNewFrameworkSoftware2013, we will use a Gamma prior distribution for $R_t$ with shape $a_0 = 1$ and rate $b_0 = 0.2$. As our likelihood is a Poisson distribution, we have a conjugate prior-likelihood, and thus our posterior distribution for $R_t$ is:\n\n$$\nR_t | C_{1:t} \\sim \\text{Gamma}\\left(a_0 + C_t, b_0 + \\sum_{u=1}^{u_{max}} C_{t-u} \\omega_u \\right)\n$$ {#eq-intro-simpleposterior}\n\n::: {#e66739b1 .cell execution_count=8}\n``` {.julia .cell-code}\n(MeanRt, LowerRt, UpperRt) = (zeros(T), zeros(T), zeros(T)) # Pre-allocate results vectors\n(a0, b0) = (1, 1/5) # Set prior parameters\n\nfor tt = 2:T\n\n    # Find the posterior distribution on day t\n    a = a0 + C[tt]\n    b = b0 + sum(C[tt-1:-1:1] .* ω[1:tt-1])/sum(ω[1:tt-1])\n    PosteriorDist = Gamma(a, 1/b)\n\n    # Save the results\n    MeanRt[tt] = mean(PosteriorDist)\n    LowerRt[tt] = quantile(PosteriorDist, 0.025)\n    UpperRt[tt] = quantile(PosteriorDist, 0.975)\n\nend\n```\n:::\n\n\nWe will compare our estimates with those from a popular model, EpiEstim, which smooths the data by assuming $R_t$ is fixed over a $\\tau$-day (typically $\\tau = 7$) trailing window:\n\n::: {#547b71ad .cell execution_count=9}\n``` {.julia .cell-code}\ninclude(\"../src/RtEstimators.jl\")\nEpiEstimPosterior = EpiEstim(7, ω, C; a0=a0, b0=b0)\n(EpiEstMean, EpiEstLower, EpiEstUpper) = (mean.(EpiEstimPosterior), quantile.(EpiEstimPosterior, 0.025), quantile.(EpiEstimPosterior, 0.975))\n```\n:::\n\n\nFinally, we are ready to plot our results:\n\n::: {#cell-fig-intro-exampleRt .cell execution_count=10}\n``` {.julia .cell-code code-fold=\"true\"}\nplot(xlabel=\"Time (days)\", ylabel=\"Reproduction number\", size=(800,350), left_margin=3mm, bottom_margin=3mm)\nplot!(2:T, MeanRt[2:T], ribbon=(MeanRt[2:T]-LowerRt[2:T], UpperRt[2:T]-MeanRt[2:T]), fillalpha=0.4, label=\"Unsmoothed posterior\")\nplot!(2:T, EpiEstMean[2:T], ribbon=(EpiEstMean[2:T]-EpiEstLower[2:T], EpiEstUpper[2:T]-EpiEstMean[2:T]), fillalpha=0.4, label=\"EpiEstim (smoothed) posterior\")\nplot!(1:T, R, label=\"True Rt\", color=:black)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n![Estimates of Rt from the basic (unsmoothed) renewal model (blue) and from a smoothed model (EpiEstim, orange).](introduction_files/figure-html/fig-intro-examplert-output-1.svg){#fig-intro-examplert}\n:::\n:::\n\n\n### The necessity and dangers of smoothing {#sec-intro-smoothing}\n\n@fig-intro-exampleRt highlights both the necessity and dangers of smoothing. Our independent daily estimates (blue) are highly variable and the credible intervals are wide. By using smoothed estimates (orange), we reduce this variance and produce much more confident results. However, our results strongly depend on these smoothing assumptions. In the example above, we can clearly see that the credible intervals produced by EpiEstim often do not include the true value of $R_t$!\n\nSmoothing works by allowing data from multiple days to inform point-estimates. A variety of approaches have been developed, discussed at length in @sec-smoothingmethods. **In fact, most renewal-model based estimators of $R_t$ differ only in their choice of smoothing method!**\n\nEpidemic renewal models are usually smoothed by placing assumptions on the dynamics of $R_t$. Examples include assuming $R_t$ is fixed over trailing windows [@coriNewFrameworkSoftware2013], modelling it with splines [@azmonEstimationReproductionNumber2014] or Gaussian processes [@abbottEstimatingTimevaryingReproduction2020], or assuming it follows a random walk [@paragImprovedEstimationTimevarying2021]. Piecewise-constant models, where $R_t$ is assumed to be fixed over different time-windows, are also examples of smoothing [@creswellBayesianNonparametricMethod2023].\n\nSo far we have only considered process noise in the epidemic, but epidemic data are often subject to observation noise, a secondary reason why smoothing is so important. We elaborate on this in #TODO.\n\n\n\n\n\n<!-- \nTo account for this noise, popular $R_t$ estimators utilise smoothing methods to increase the quantity of data available on each time-step. These smoothing methods typically take the form of a dynamic model on $R_t$. An extensive discussion of existing smoothing methods is included [here](link.link) [\\#TODO: Write-up smoothing comparison]. -->\n\n<!-- ### A dynamic model for $R_t$\n\nThe primary requirement for using our SMC-methods is a *sequential* dynamic model. That is, we want a model for the evolution of $R_t$ that looks like:\n\n$$\nP(R_t | R_{1:t-1}) = f(R_{1:t-1})\n$$\n\nfor some arbitrary probability density (or mass) function $f$.\n\nWe employ a default model similar to that used by EpiFilter [@paragImprovedEstimationTimevarying2021], specifically a Gaussian random walk:\n\n$$\n\\log R_t | \\log R_{t-1} \\sim \\text{Normal}(\\log R_{t-1}, \\sigma)\n$$ {#eq-intro-rtmodel}\n\nDesign choices in this model include:\n\n- The Gaussian random walk encodes the assumption that $R_t4 varies smoothly over time\n- Modelling on a log-scale allows $R_t$ to vary faster at larger values\n -->\n\n## The serial interval\n\nThe other key component in the renewal model is the serial interval $\\omega$. This parameter is typically not identifiable from reported case data (at least at the same time as $R_t$), so it often receives less attention. When fitting renewal models, researchers usually use estimates of the serial interval from other data.\n\nExternal estimates of $\\omega$. \n\n<!-- ## Statistical noise\n\n#TODO: Copy to somewhere else\n\nStatistical noise in reported cases time-series can be separated into two categories:\n\n1. **Process noise**: the true dynamics of $R_t$ are unknown and the underlying infection process is inherently stochastic\n2. **Observation noise**: case reporting may be delayed, incomplete, or feature a number of other biases.   -->\n\n## Reported cases vs infections {#sec-intro-casesvsinfections}\n\nThe simple renewal model in @eq-intro-poissonrenewal assumes that old reported cases directly cause new reported cases. This leaves little room for observation noise. Instead, we can assume that old (but typically unobserved) infections cause new infections, writing:\n\n$$\nI_t|R_t, I_{1:t-1} \\sim \\text{Poisson}\\left(R_t \\Lambda_t\\right)\n$$ {#eq-intro-infectionrenewal}\n\nThe force-of-infection becomes:\n\n$$\n\\Lambda_t = \\sum_{u=1}^{u_{max}} I_{t-u} g_u\n$$ {#eq-intro-forceofinfectioninc}\n\nWhere we have replaced the serial interval $\\omega_u$ with a generation time distribution $g_u$, reflecting that we are modelling the delay between infection events instead of reporting events.\n\nExplicitly modelling infections allows us to define an observation distribution:\n\n$$\nP(C_t | I_{1:t})\n$$ {#eq-intro-obsdist}\n\nwhich explicitly links our hidden (a.k.a latent) infections to our reported cases. A plethora of methods exist that can estimate $I_{1:T}$ given $C_{1:T}$.\n\nSeparating case reporting from transmission allows us to model process noise and observation noise separately. This is one of the key advantages provided by our SMC methods.\n\n",
    "supporting": [
      "introduction_files"
    ],
    "filters": [],
    "includes": {}
  }
}