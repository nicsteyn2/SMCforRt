{
  "hash": "d852ead2b271f12632b32ee1d57d75a4",
  "result": {
    "engine": "jupyter",
    "markdown": "# Structure of pre-built functions {#sec-structure}\n\n::: {#4b87e798 .cell execution_count=1}\n``` {.julia .cell-code code-fold=\"true\"}\nusing Distributions\ninclude(\"../src/loadData.jl\")\n```\n:::\n\n\n## Primary function\n\nThe provided code is built around a user-written function, denoted here ```bootstrapFilter(θ, Y, opts)``` . This function should encode the user's entire state-space model by implementing a bootstrap filter, including initialisation and the projection-weighting-resampling steps.\n\nThis function should accept:\n\n- A parameter vector ```θ```\n- Sorted dataframe of data ```Y```\n- Options dictionary ```opts```\n\nand should return a tuple of the form ```(X, W)```, where:\n\n- ```X``` contains the particle values (typically in the form of an $N \\times T \\times S$ vector where $S$ is the number of hidden-states)\n- ```W``` is a $N \\times T$ matrix of observation weights\n\n### Example\n\nOnly minor modifications need to be made to the example in @sec-smc-pmmhexamplefunc in order to satisfy these requirements:\n\n::: {#0e4bc508 .cell execution_count=2}\n``` {.julia .cell-code code-fold=\"true\"}\nσ = 0.1 # Model parameters\nnzdata = loadData(\"NZCOVID\") # Dataframe containing model data\nopts = Dict() # A dictionary of parameter values\nopts[\"T\"] = length(nzdata.Ct)\nopts[\"N\"] = 10000\nopts[\"pR0\"] = Uniform(0, 10)\n\nfunction runSimpleModel(σ, nzdata::DataFrame, opts::Dict)\n\n    # Extract frequently used options\n    T = opts[\"T\"]\n    N = opts[\"N\"]\n\n    # Initialise output matrices\n    X = zeros(N, T)\n    W = zeros(N, T)\n\n    # Sample from initial distribution\n    X[:,1] = rand.(opts[\"pR0\"], N)\n\n    # Run the filter\n    for tt = 2:T\n\n        # Project according to the state-space model\n        X[:,tt] = exp.(rand.(Normal.(log.(X[:,tt-1]), σ)))\n\n        # Weight according to the observation model\n        Λ = sum(nzdata.Ct[tt-1:-1:1] .* ω[1:tt-1])\n        W[:,tt] = pdf.(Poisson.(X[:,tt] .* Λ), nzdata.Ct[tt])\n\n        # Resample\n        inds = wsample(1:N, W[:,tt], N; replace=true)\n        X[:, max(tt - L, 1):tt] = X[inds, max(tt - L, 1):tt]\n\n    end\n\n    return(X, W)\n\nend\n```\n:::\n\n\n## Pre-built functions\n\nWe provide a collection of functions that accept ```bootstrapFilter``` (and also ```θ```, ```Y```, and ```opts```, depending on the function) as an argument:\n\n|Function|Description|\n|-|---|\n|```estimateLoglik()```|Calculates and returns the log-likelihood estimate (@eq-smc-likelihoodest). Includes optional argument ```ignoreerror``` (default false), that returns $-\\infty$ if the model returns an error.|\n|```simplePMMH()```| A simple implementation of the PMMH algorithm. Returns a matrix of accepted values ```C``` and a matrix of sampled values with the corresponding likelihood estimate and accept/reject decision ```OUT```.|\n|```simplePMMHMulti()``` | A multithreaded wrapper of ```simplePMMH()```. |\n|```PMMH()```| A (slightly) more comprehensive and adaptive implementation of the PMMH algorithm. Returns the same arguments, as well as a diagnostics dataframe. |\n|```PMMHMulti()``` | A multithreaded wrapper of ```PMMH()```. |\n\n",
    "supporting": [
      "structure_files"
    ],
    "filters": [],
    "includes": {}
  }
}