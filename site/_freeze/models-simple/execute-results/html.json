{
  "hash": "9fa751166804f0d183130b89f960a253",
  "result": {
    "engine": "jupyter",
    "markdown": "# Introductory models  {#sec-models-simple}\n\n<!-- ---\neval: false\n--- -->\n\nWe begin by fitting the three example models introduced in @sec-intro-hiddenstatemodels-examples of @sec-intro-hiddenstatemodels to real-world data.\n\nFirst we load and plot the data we will use for our examples. These are the national reported cases for the first 100 days of the COVID-19 pandemic in Aotearoa New Zealand [@ministryofhealthnzNewZealandCOVID192024], downloaded from [here](https://github.com/minhealthnz/nz-covid-data).\n\n::: {#cell-fig-models-simple-data .cell execution_count=1}\n``` {.julia .cell-code}\ninclude(\"../src/LoadData.jl\")\nY = loadData(\"NZCOVID\")\n\nusing Plots, Measures\nbar(Y.date, Y.Ct, color=:darkblue, size=(800,400), xlabel=\"Date\", ylabel=\"Reported cases\", label=false, margins=3mm)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n![Reported cases for the first 100 days of the COVID-19 pandemic in Aotearoa New Zealand [@ministryofhealthnzNewZealandCOVID192024].](models-simple_files/figure-html/fig-models-simple-data-output-1.svg){#fig-models-simple-data}\n:::\n:::\n\n\n## Example 1\n\nIn this example, we use a Gamma$(1, 0.2)$ prior distribution for $R_t$ which forms the **state-space transition distribution**:\n\n$$\nR_t \\sim \\text{Gamma}(1, 1/0.2)\n$$\n\nand use the Poisson renewal model (with a Gamma(2.36, 27.4) distribution for the serial interval) for the **observation distribution**:\n\n$$\nC_t | R_t, C_{1:t-1} \\sim \\text{Poisson}\\left(R_t \\sum_{u=1}^{u_{max}} C_{t-u} \\omega_u\\right)\n$$\n\nWe write this as a hidden-state model in Julia:\n\n::: {#34a3c6ed .cell execution_count=2}\n``` {.julia .cell-code}\nfunction ExampleModel1(θ, Y::DataFrame, opts::Dict)\n\n    # Extract frequently used options\n    T = opts[\"T\"] # Number of time steps\n    N = opts[\"N\"] # Number of particles to use\n\n    # Define the serial interval\n    ω = pdf.(Gamma(2.36, 2.74), 1:100) # (Unnormalised) serial interval\n    ω = ω/sum(ω) # Normalise the serial interval\n\n    # Initialise output matrices\n    R = zeros(N, T) # Matrix to store particle values\n    W = zeros(N, T) # Matrix to store model weights\n\n    # Run the filter\n    for tt = 2:T\n\n        # \"Project\" according to the state-space model\n        R[:,tt] = rand(Gamma.(1, 1/0.2), N)\n\n        # Weight according to the observation model\n        Λ = sum(Y.Ct[tt-1:-1:1] .* ω[1:tt-1])/sum(ω[1:tt-1]) # Calculate the force-of-infection\n        W[:,tt] = pdf.(Poisson.(R[:,tt] .* Λ), Y.Ct[tt])\n\n        # Resample\n        inds = wsample(1:N, W[:,tt], N; replace=true)\n        R[:, tt] = R[inds, tt]\n\n    end\n\n    return(R, W)\n\nend\n```\n:::\n\n\n::: {.callout-tip}\n\nAs there is no autocorrelation in the state-space model, and the observation distributon depends only on the hidden-states at time $t$, we do not need to bother with any fixed-lag resampling.\n\n:::\n\nThere are no parameters to estimate, so we simply fit this model to the data:\n\n::: {#aba8b4c5 .cell execution_count=3}\n``` {.julia .cell-code}\n# Specify bootstrap filter options (the {String, Any} term allows us to use any type of value in this dictionary)\nopts = Dict{String, Any}(\"N\" => 1000, \"T\" => 100)\n\n# Fit the model\n(R, W) = ExampleModel1(missing, Y, opts) # θ is missing as there are no \"parameters\" in this model!\n\n# Extract posterior means and credible intervals\nMeanRt = vec(mean(R, dims=1)) # \"dims=1\" tells Julia to take column-wise means, vec(.) turns the resulting 1xN matrix into a vector\nLowerRt = [quantile(Rt, 0.025) for Rt in eachcol(R)]\nUpperRt = [quantile(Rt, 0.975) for Rt in eachcol(R)]\n```\n:::\n\n\nWe can also find the posterior means and credible intervals for this model analytically (@sec-intro-Rtestimation).\n\n::: {#774670cc .cell execution_count=4}\n``` {.julia .cell-code code-fold=\"true\"}\n(MeanRtTrue, LowerRtTrue, UpperRtTrue) = (zeros(opts[\"T\"]), zeros(opts[\"T\"]), zeros(opts[\"T\"])) # Pre-allocate results vectors\n(a0, b0) = (1, 1/5) # Set prior parameters\n\n# Define the serial interval\nω = pdf.(Gamma(2.36, 2.74), 1:100) # (Unnormalised) serial interval\nω = ω/sum(ω) # Normalise the serial interval\n\nfor tt = 2:opts[\"T\"]\n\n    # Find the posterior distribution on day t\n    a = a0 + Y.Ct[tt]\n    b = b0 + sum(Y.Ct[tt-1:-1:1] .* ω[1:tt-1])/sum(ω[1:tt-1])\n    PosteriorDist = Gamma(a, 1/b)\n\n    # Save the results\n    MeanRtTrue[tt] = mean(PosteriorDist)\n    LowerRtTrue[tt] = quantile(PosteriorDist, 0.025)\n    UpperRtTrue[tt] = quantile(PosteriorDist, 0.975)\n\nend\n```\n:::\n\n\nPlotting the estimates from the bootstrap filter against the analytical posterior mean and credible intervals demonstrates the SMC approxmation is of high quality.\n\n::: {#cell-fig-models-simple-example1 .cell execution_count=5}\n``` {.julia .cell-code}\n# Process the results and plot\npltR = plot(size=(800,400), xlabel=\"Date\", ylabel=\"Reproduction number\", margins=3mm)\npltR = plot!(pltR, Y.date, MeanRtTrue, ribbon=(MeanRtTrue-LowerRtTrue, UpperRtTrue-MeanRtTrue), color=:lightgreen, label=\"Rt (analytical)\")\npltR = plot!(pltR, Y.date, MeanRt, ribbon=(MeanRt-LowerRt, UpperRt-MeanRt), color=:darkgreen, label=\"Rt (from SMC)\")\nhline!([1], color=:black, linestyle=:dash, label=\"Rt = 1\")\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n![Reproduction number estimates from example model 1 fit to data from the first 100 days of COVID-19 in Aotearoa New Zealand. N = 1000 particles are used in the SMC approxmation, resulting in a very good approximation to the analytical posterior means and credible intervals over time.](models-simple_files/figure-html/fig-models-simple-example1-output-1.svg){#fig-models-simple-example1}\n:::\n:::\n\n\n## Example 2\n\n@fig-models-simple-example1 demonstrates considerable variability in $R_t$ estimates. In pratice, we want to produce smoothed estimates ([@sec-intro-smoothing]).\n\nWe update the state-space model to use a Gaussian random walk on $\\log R_t$:\n\n$$\nR_t | R_{t-1} \\sim \\text{Normal}\\left(R_{t-1}, \\eta \\sqrt{R_{t-1}}\\right)\n$$\n\nIn Julia\n\n::: {#48348d18 .cell execution_count=6}\n``` {.julia .cell-code}\nfunction ExampleModel2(θ, Y::DataFrame, opts::Dict)\n\n    # Extract frequently used options\n    T = opts[\"T\"] # Number of time steps\n    N = opts[\"N\"] # Number of particles to use\n    L = opts[\"L\"] # Length of fixed-lag resampling\n\n    # Define the serial interval\n    ω = pdf.(Gamma(2.36, 2.74), 1:100) # (Unnormalised) serial interval\n    ω = ω/sum(ω) # Normalise the serial interval\n\n    # Initialise output matrices\n    R = zeros(N, T) # Matrix to store particle values\n    W = zeros(N, T) # Matrix to store model weights\n\n    # Sample from initial distribution\n    R[:,1] = rand(Uniform(0, 10), N)\n\n    # Run the filter\n    for tt = 2:T\n\n        # \"Project\" according to the state-space model\n        R[:,tt] = exp.(rand.(Normal.(log.(R[:,tt-1]), θ)))\n\n        # Weight according to the observation model\n        Λ = sum(Y.Ct[tt-1:-1:1] .* ω[1:tt-1])/sum(ω[1:tt-1]) # Calculate the force-of-infection\n        W[:,tt] = pdf.(Poisson.(R[:,tt] .* Λ), Y.Ct[tt])\n\n        # Resample\n        inds = wsample(1:N, W[:,tt], N; replace=true)\n        R[:, max(tt - L, 1):tt] = R[inds, max(tt - L, 1):tt]\n\n    end\n\n    return(R, W)\n\nend\n```\n:::\n\n\n",
    "supporting": [
      "models-simple_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}