{
  "hash": "e3d1674d3c1a496ca0edb7a656401387",
  "result": {
    "engine": "jupyter",
    "markdown": "# Simulated data\n\nIt is useful to test our models on simulated data where we know what the true value of $R_t$ is. Our simulations are broken into two stages:\n\n1. Simulating the underlying epidemic\n2. Simulating the observation process\n\nUnsurprisingly, these correspond to the state-space model and observation model in the SMC algorithm.\n\n## Simulating the underlying epidemic\n\nAll our simulations leverage the *Poisson renewal model*:\n\n$$ I_t \\sim \\text{Poisson}(R_t \\Lambda_t) $$\n\nwhere the *force-of-infection* is defined as:\n\n$$ \\Lambda_t = \\sum_{u = 0}^{t-1} I_{t-u} g_u $$\n\nfor some generation time distriubtion $g_u$.\n\nUnless otherwise stated, we assume a Gaussian random walk for $\\log R_t$:\n\n$$ \\log R_t \\sim \\text{Normal}(\\log R_{t-1}, \\sigma) $$\n\nwhere $\\sigma$ determines how quickly $R_t$ varies. This matches the state-space model assumed by our default methods.\n\nSimulations are initialised with $I_1$ infections (default 10) and an initial value of $R_1$ (default 2). We then iteratively sample $R_t$ and $I_t$ from the above model for $t = 2, ..., T$ (default $T = 100$). The core script looks like:\n\n```julia\n# Initialise vectors\nlogRt = zeros(T)\nlogRt[1] = log(R1)\nIt = zeros(T)\nIt[1] = log(I1)\n\nfor tt = 2:T\n    # Sample logRt from a normal distribution\n    logRt[tt] = rand(Normal(logRt[tt], σ))\n\n    # Calculate the force of infection\n    Λt = sum(It[tt-1:-1:1] .* g[1:tt-1]) \n\n    # Sample the number of new infections\n    It[tt] = rand(Poisson(exp(logRt[tt]) * Λt))\nend\n\n# Combine into a single dataframe\nY = DataFrame(t=1:T, It=It, Rt=Rt)\n```\n\nAlthough additional code is included to ensure that total infections are between 100 and 100,000 (by default) and that $R_t$ is between 0.2 and 5 (by default). The resulting function ```simulateSimpleEpidemic()``` is provided in ```/src/Simulations.jl```. We call it here:\n\n::: {#f550f634 .cell execution_count=1}\n``` {.julia .cell-code}\n# using Random, Plots\n# Random.seed!(42)\n\n# include(\"../src/Simulations.jl\")\n\n# Y = simulateSimpleEpidemic()\n\n# plot(plot(Y.Rt, ylabel=\"Reproduction number\", label=false), plot(Y.It, ylabel=\"Infections\", label=false), layout=(2,1))\n```\n:::\n\n\n*This is also the script that was used to generate \"simulated_simple.csv\". We save it instead of calling it each time as the Random seed is not consistent between environments.*\n\n\n## Simulating the observation process\n\nIf we are simulating the simple model then we set $C_t = I_t$ (reported cases = infections) and we are done. Or we can simulate from any number of observation processes. We outline some here.\n\n*All functions created here are included in ```src/Simulations.jl```.*\n\n### Binomial reporting\n\nIn the simple underreporting case, we might have:\n$$ C_t \\sim \\text{Binomial}(I_t, \\rho) $$\n\nfor some underreporting fraction $\\rho$. We can implement this as:\n\n::: {#926910b2 .cell execution_count=2}\n``` {.julia .cell-code}\nusing Distributions\n\n# function simulateBinomialReporting(It, ρ)\n\n#     Ct = rand.(Binomial.(It, ρ))\n#     return(Ct)\n\n# end\n\n# Y.Ct = simulateBinomialReporting(Y.It, 0.5)\n\n# plot(Y.It, ylabel=\"Infections\", label=\"True infections\", title=\"Binomial reporting example\", size=(800,400), dpi=300)\n# plot!(Y.Ct, label=\"Reported cases\")\n```\n:::\n\n\n### Delayed reporting\n\nOr we might assume that cases are underreported and delayed:\n$$ C_t \\sim \\text{Binomial}\\left(\\sum_{u=0}^{u_{max}} I_{t-u} d_u, \\ \\rho\\right) $$\n\nIf we assume $\\rho = 80\\%$ of cases are reported, and the delay distribution is negative binomial with mean 5.6 and standard deviation 3.2, we can implement:\n\n::: {#78eb8301 .cell execution_count=3}\n``` {.julia .cell-code}\n# function simulateBinomialUnderreportNegBinDelay(It, ρ, r, p)\n\n#     d = pdf.(NegativeBinomial(r, p), 0:length(It))\n#     DelayedIt = round.([sum(It[tt:-1:1] .* d[1:tt]) for tt = 1:length(It)])\n#     Ct = rand.(Binomial.(DelayedIt, ρ))\n#     return(Ct)\n\n# end\n\n# Y.Ct = simulateBinomialUnderreportNegBinDelay(Y.It, 0.8, 7, 5/9)\n\n# plot(Y.It, ylabel=\"Infections\", label=\"True infections\", title=\"Binomial reporting and negative binomial delay\", size=(800,400), dpi=300)\n# plot!(Y.Ct, label=\"Reported cases\")\n```\n:::\n\n\n## Extensions\n\n### Including imported cases\n\n",
    "supporting": [
      "simulateddata_files"
    ],
    "filters": [],
    "includes": {}
  }
}